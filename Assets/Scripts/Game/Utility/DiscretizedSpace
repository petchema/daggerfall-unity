using System;
using System.Collections.Generic;
using DaggerfallWorkshop.Utility;
using UnityEngine;

namespace DaggerfallWorkshop.Game.Utility
{

    [System.Serializable]
    public class OverRaycastBudgetException : System.Exception
    {
        public OverRaycastBudgetException() { }
        public OverRaycastBudgetException(string message) : base(message) { }
        public OverRaycastBudgetException(string message, System.Exception inner) : base(message, inner) { }
        protected OverRaycastBudgetException(
            System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
    }

    public class DiscretizedSpace
    {
        private Vector3 origin;
        private Vector3 step;
        private int raycastBudget = 0;

        public struct Movement
        {
            public readonly Vector3 delta;
            public readonly float cost;
        }
        private static List<Movement> movements = null;
        public DiscretizedSpace(Vector3 origin, Vector3 step)
        {
            this.origin = origin;
            this.step = step;
            raycastBudget = 0;
            if (movements == null)
            {
                movements = new List<Movement>();
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        for (int z = -1; z <= 1; z++)
                        {
                            if (x != 0 || y != 0 || z != 0)
                            {
                                float cost = Mathf.Sqrt(x * x + y * y + z * z);
                                Movement movement = new Movement(x, y, z, cost);
                                movements.Add(movement);
                            }
                        }
                    }
                }
            }
        }

        public void SetRaycastBudget(int budget)
        {
            raycastBudget = budget;
        }

        private void DecrRaycastBudget()
        {
            if (raycastBudget > 0)
                raycastBudget--;
            else 
                throw new OverRaycastBudgetException();
        }

        public Vector3Int Discretize(Vector3 vector)
        {
            return new Vector3Int((int) Mathf.Floor((vector.x - origin.x) / step.x),
                                (int) Mathf.Floor((vector.y - origin.y) / step.y),
                                (int) Mathf.Floor((vector.z - origin.z) / step.z));
        }

        public Vector3 Reify(Vector3Int gridNode)
        {
            return new Vector3(origin.x + gridNode.x * step.x,
                            origin.y + gridNode.y * step.y,
                            origin.z + gridNode.z * step.z);
        }

        public bool IsNeighboor(Vector3 source, Vector3 destination)
        {
            return Mathf.Abs(destination.x - source.x) < step.x &&
                Mathf.Abs(destination.y - source.y) < step.y &&
                Mathf.Abs(destination.z - source.z) < step.z;
        }
        public bool IsNeighboor(Vector3Int sourceGridNode, Vector3 destination)
        {
            return IsNeighboor(Reify(sourceGridNode), destination);
        }

        public float HeuristicCost(Vector3 source, Vector3 destination)
        {
            return Vector3.Distance(source, destination);
        }
        public float MeasuredCost(Vector3 source, Vector3 destination)
        {
            return Vector3.Distance(source, destination);
        }
        public float MeasuredCostInt(Vector3Int sourceGridNode, Vector3Int destinationGridNode)
        {
            return Vector3Int.Distance(sourceGridNode, destinationGridNode);
        }
        public List<Movement> GetMovements()
        {
            return movements;
        }

        public List<Vector3> RebuildPath(ChainedPath path)
        {
            List<Vector3> result = new List<Vector3>();
            while (path != null)
            {
                result.Add(Reify(path.position));
                path = path.source;
            }
            result.Reverse();
            return result;
        }
    
        private static int defaultLayerOnlyMask = 0;
        private RaycastHit[] hitsBuffer = new RaycastHit[4];

        public bool IsNavigable(Vector3 source, Vector3 destination)
        {
            Vector3 vector = destination - source;
            Vector3 normalized = vector.normalized;
            // Add some overlap, because paths can get thru walls if a node lands exactly on a wall
            float epsilon = 0.01f;
            if (defaultLayerOnlyMask == 0)
                defaultLayerOnlyMask = 1 << LayerMask.NameToLayer("Default");

            Ray ray = new Ray(source - normalized * epsilon, normalized);
            int nhits;
            while (true) {
                DecrRaycastBudget();
                nhits = Physics.RaycastNonAlloc(ray, hitsBuffer, vector.magnitude + 2f * epsilon, defaultLayerOnlyMask);
                if (nhits < hitsBuffer.Length)
                    break;
                // hitsBuffer may have overflowed, retry with a larger buffer
                hitsBuffer = new RaycastHit[nhits + 1];
            };
            bool navigable = true;
            for (int i = 0; i < nhits; i++)
            {
                if (GameObjectHelper.IsStaticGeometry(hitsBuffer[i].transform.gameObject))
                {
                    navigable = false;
                    break;
                }
            }
            // Debug.DrawLine(source, destination, navigable ? Color.green : Color.red, 1f, true);
            return navigable;
        }
    }
}